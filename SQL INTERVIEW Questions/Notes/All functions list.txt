************** Calculate running total function ***********************
https://www.youtube.com/watch?v=BMzZmq12YJI&list=PL08903FB7ACA1C2FB&index=113


sql query to compute running total without partitions

We will use the following Employees table for the examples in this video.

SQL Script to create Employees table
Create Table Employees
(
 Id int primary key,
 Name nvarchar(50),
 Gender nvarchar(10),
 Salary int
)
Go

Insert Into Employees Values (1, 'Mark', 'Male', 5000)
Insert Into Employees Values (2, 'John', 'Male', 4500)
Insert Into Employees Values (3, 'Pam', 'Female', 5500)
Insert Into Employees Values (4, 'Sara', 'Female', 4000)
Insert Into Employees Values (5, 'Todd', 'Male', 3500)
Insert Into Employees Values (6, 'Mary', 'Female', 5000)
Insert Into Employees Values (7, 'Ben', 'Male', 6500)
Insert Into Employees Values (8, 'Jodi', 'Female', 7000)
Insert Into Employees Values (9, 'Tom', 'Male', 5500)
Insert Into Employees Values (10, 'Ron', 'Male', 5000)
Go

SQL Query to compute running total without partitions
SELECT Name, Gender, Salary, 
    SUM(Salary) OVER (ORDER BY ID) AS RunningTotal
FROM Employees

SQL Query to compute running total with partitions
SELECT Name, Gender, Salary, 
    SUM(Salary) OVER (PARTITION BY Gender ORDER BY ID) AS RunningTotal
FROM Employees

What happens if I use order by on Salary column
If you have duplicate values in the Salary column, all the duplicate values will be added to the running total at once. In the example below notice that we have 5000 repeated 3 times. So 15000 (i.e 5000 + 5000 + 5000) is added to the running total at once. 

SELECT Name, Gender, Salary, 
    SUM(Salary) OVER (ORDER BY Salary) AS RunningTotal
FROM Employees

So when computing running total, it is better to use a column that has unique data in the ORDER BY clause.


************************* Choose function ******************************
Choose function in sql OR the ELT() function does essentially the same thing in mysql

Introduced in SQL Server 2012
Returns the item at the specified index from the list of available values
The index position starts at 1 and NOT 0 (ZERO)

Syntax : CHOOSE ( index, val_1, val_2, ... )

Example : Returns the item at index position 2

SELECT CHOOSE(2, 'India','US', 'UK') AS Country

Example : Using CHOOSE() function with table data. 

We will use the following Employees table for this example.

SQL Script to create Employees table
Create table Employees
(
 Id int primary key identity,
 Name nvarchar(10),
 DateOfBirth date
)
Go

Insert into Employees values ('Mark', '01/11/1980')
Insert into Employees values ('John', '12/12/1981')
Insert into Employees values ('Amy', '11/21/1979')
Insert into Employees values ('Ben', '05/14/1978')
Insert into Employees values ('Sara', '03/17/1970')
Insert into Employees values ('David', '04/05/1978')
Go

We want to display Month name along with employee Name and Date of Birth.

Using CASE statement in SQL Server

SELECT Name, DateOfBirth, 
    CASE DATEPART(MM, DateOfBirth)
    WHEN 1 THEN 'JAN'
    WHEN 2 THEN 'FEB'
    WHEN 3 THEN 'MAR'
    WHEN 4 THEN 'APR'
    WHEN 5 THEN 'MAY'
    WHEN 6 THEN 'JUN'
    WHEN 7 THEN 'JUL'
    WHEN 8 THEN 'AUG'
    WHEN 9 THEN 'SEP'
    WHEN 10 THEN 'OCT'
    WHEN 11 THEN 'NOV'
    WHEN 12 THEN 'DEC'
    END
       AS [MONTH]
FROM Employees

Using CHOOSE function in SQL Server : The amount of code we have to write is lot less than using CASE statement.

SELECT Name, DateOfBirth,CHOOSE(DATEPART(MM, DateOfBirth), 
       'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 
       'SEP', 'OCT', 'NOV', 'DEC') AS [MONTH]
FROM Employees



************************* IIF function ******************************

Returns one of two the values, depending on whether the Boolean expression evaluates to true or false
IIF is a shorthand way for writing a CASE expression

Syntax : IIF ( boolean_expression, true_value, false_value )

Example : Returns Male as the boolean expression evaluates to TRUE

DECLARE @Gender INT
SET @Gender = 1
SELECT IIF( @Gender = 1, 'Male', 'Femlae') AS Gender

Example : Using IIF() function with table data. We will use the following Employees table for this example.

SQL Script to create Employees table
Create table Employees
(
 Id int primary key identity,
 Name nvarchar(10),
 GenderId int
)
Go

Insert into Employees values ('Mark', 1)
Insert into Employees values ('John', 1)
Insert into Employees values ('Amy', 2)
Insert into Employees values ('Ben', 1)
Insert into Employees values ('Sara', 2)
Insert into Employees values ('David', 1)
Go

Write a query to display Gender along with employee Name and GenderId. We can achieve this either by using CASE or IIF.

Using CASE statement
SELECT Name, GenderId, 
    CASE WHEN GenderId = 1
      THEN 'Male'
      ELSE 'Female'
    END AS Gender
FROM Employees

Using IIF function
SELECT Name, GenderId, IIF(GenderId = 1, 'Male', 'Female') AS Gender
FROM Employees

************************ TRY_PARSE function ******************************
TRY_PARSE function
  Introduced in SQL Server 2012
  Converts a string to Date/Time or Numeric type
  Returns NULL if the provided string cannot be converted to the specified data type
  Requires .NET Framework Common Language Runtime (CLR)

Syntax : TRY_PARSE ( string_value AS data_type )

Example : Convert string to INT. As the string can be converted to INT, the result will be 99 as expected.

SELECT TRY_PARSE('99' AS INT) AS Result

Example : Convert string to INT. The string cannot be converted to INT, so TRY_PARSE returns NULL

SELECT TRY_PARSE('ABC' AS INT) AS Result

Use CASE statement or IIF function to provide a meaningful error message instead of NULL when the conversion fails.

Example : Using CASE statement to provide a meaningful error message when the conversion fails.

SELECT 
CASE WHEN TRY_PARSE('ABC' AS INT) IS NULL
  THEN 'Conversion Failed'
  ELSE 'Conversion Successful'
END AS Result

Output : As the conversion fails, you will now get a message 'Conversion Failed' instead of NULL

Example : Using IIF function to provide a meaningful error message when the conversion fails.

SELECT IIF(TRY_PARSE('ABC' AS INT) IS NULL, 'Conversion Failed', 
         'Conversion Successful') AS Result

What is the difference between PARSE and TRY_PARSE
PARSE will result in an error if the conversion fails, where as TRY_PARSE will return NULL instead of an error. 

Since ABC cannot be converted to INT, PARSE will return an error
SELECT PARSE('ABC' AS INT) AS Result

Since ABC cannot be converted to INT, TRY_PARSE will return NULL instead of an error
SELECT TRY_PARSE('ABC' AS INT) AS Result

Example : Using TRY_PARSE() function with table data. We will use the following Employees table for this example.

SQL Script to create Employees table
Create table Employees
(
 Id int primary key identity,
 Name nvarchar(10),
 Age nvarchar(10)
)
Go

Insert into Employees values ('Mark', '40')
Insert into Employees values ('John', '20')
Insert into Employees values ('Amy', 'THIRTY')
Insert into Employees values ('Ben', '21')
Insert into Employees values ('Sara', 'FIFTY')
Insert into Employees values ('David', '25')
Go

The data type of Age column is nvarchar. So string values like (THIRTY, FIFTY ) are also stored. Now, we want to write a query to convert the values in Age column to int and return along with the Employee name. Notice TRY_PARSE function returns NULL for the rows where age cannot be converted to INT.

SELECT Name, TRY_PARSE(Age AS INT) AS Age
FROM Employees

If you use PARSE instead of TRY_PARSE, the query fails with an error.

SELECT NAME, PARSE(Age AS INT) AS Age
FROM Employees

The above query returns the following error
Error converting string value 'THIRTY' into data type int using culture

********************** TRY_CONVERT function ******************************

TRY_CONVERT function
Introduced in SQL Server 2012
Converts a value to the specified data type
Returns NULL if the provided value cannot be converted to the specified data type
If you request a conversion that is explicitly not permitted, then TRY_CONVERT fails with an error

Syntax : TRY_CONVERT ( data_type, value, [style] )

Style parameter is optional. The range of acceptable values is determined by the target data_type. For the list of all possible values for style parameter, please visit the following MSDN article
https://msdn.microsoft.com/en-us/libr...

Example : Convert string to INT. As the string can be converted to INT, the result will be 99 as expected.

SELECT TRY_CONVERT(INT, '99') AS Result

Example : Convert string to INT. The string cannot be converted to INT, so TRY_CONVERT returns NULL

SELECT TRY_CONVERT(INT, 'ABC') AS Result

Example : Converting an integer to XML is not explicitly permitted. so in this case TRY_CONVERT fails with an error

SELECT TRY_CONVERT(XML, 10) AS Result

If you want to provide a meaningful error message instead of NULL when the conversion fails, you can do so using CASE statement or IIF function.

Example : Using CASE statement to provide a meaningful error message when the conversion fails.

SELECT 
CASE WHEN TRY_CONVERT(INT, 'ABC') IS NULL
  THEN 'Conversion Failed'
  ELSE 'Conversion Successful'
END AS Result

Output : As the conversion fails, you will now get a message 'Conversion Failed' instead of NULL

Example : Using IIF function to provide a meaningful error message when the conversion fails.

SELECT IIF(TRY_CONVERT(INT, 'ABC') IS NULL, 'Conversion Failed', 
         'Conversion Successful') AS Result

What is the difference between CONVERT and TRY_CONVERT
CONVERT will result in an error if the conversion fails, where as TRY_CONVERT will return NULL instead of an error. 

Since ABC cannot be converted to INT, CONVERT will return an error
SELECT CONVERT(INT, 'ABC') AS Result

Since ABC cannot be converted to INT, TRY_CONVERT will return NULL instead of an error
SELECT TRY_CONVERT(INT, 'ABC') AS Result

Example : Using TRY_CONVERT() function with table data. We will use the following Employees table for this example.

SQL Script to create Employees table
Create table Employees
(
 Id int primary key identity,
 Name nvarchar(10),
 Age nvarchar(10)
)
Go

Insert into Employees values ('Mark', '40')
Insert into Employees values ('John', '20')
Insert into Employees values ('Amy', 'THIRTY')
Insert into Employees values ('Ben', '21')
Insert into Employees values ('Sara', 'FIFTY')
Insert into Employees values ('David', '25')
Go

The data type of Age column is nvarchar. So string values like (THIRTY, FIFTY ) are also stored. Now, we want to write a query to convert the values in Age column to int and return along with the Employee name. Notice TRY_CONVERT function returns NULL for the rows where age cannot be converted to INT.

SELECT Name, TRY_CONVERT(INT, Age) AS Age
FROM Employees

If you use CONVERT instead of TRY_CONVERT, the query fails with an error.

SELECT NAME, CONVERT(INT, Age) AS Age
FROM Employees

The above query returns the following error
Conversion failed when converting the nvarchar value 'THIRTY' to data type int.

Difference between TRY_PARSE and TRY_CONVERT functions

TRY_PARSE can only be used for converting from string to date/time or number data types where as TRY_CONVERT can be used for any general type conversions.

For example, you can use TRY_CONVERT to convert a string to XML data type, where as you can do the same using TRY_PARSE

Converting a string to XML data type using TRY_CONVERT
SELECT TRY_CONVERT(XML, '[root][child/][/root]') AS [XML]


************************* EOMONTH function ******************************

EOMONTH function
Introduced in SQL Server 2012
Returns the last day of the month of the specified date

Syntax : EOMONTH ( start_date [, month_to_add ] )

start_date : The date for which to return the last day of the month
month_to_add : Optional. Number of months to add to the start_date. EOMONTH adds the specified number of months to start_date, and then returns the last day of the month for the resulting date.

Example : Returns last day of the month November
SELECT EOMONTH('11/20/2015') AS LastDay

Example : Returns last day of the month of February from a NON-LEAP year
SELECT EOMONTH('2/20/2015') AS LastDay

Example : Returns last day of the month of February from a LEAP year
SELECT EOMONTH('2/20/2016') AS LastDay

month_to_add optional parameter can be used to add or subtract a specified number of months from the start_date, and then return the last day of the month from the resulting date.

The following example adds 2 months to the start_date and returns the last day of the month from the resulting date
SELECT EOMONTH('3/20/2016', 2) AS LastDay

The following example subtracts 1 month from the start_date and returns the last day of the month from the resulting date
SELECT EOMONTH('3/20/2016', -1) AS LastDay

Using EOMONTH function with table data. We will use the following Employees table for this example.

SQL Script to create Employees table
Create table Employees
(
 Id int primary key identity,
 Name nvarchar(10),
 DateOfBirth date
)
Go

Insert into Employees values ('Mark', '01/11/1980')
Insert into Employees values ('John', '12/12/1981')
Insert into Employees values ('Amy', '11/21/1979')
Insert into Employees values ('Ben', '05/14/1978')
Insert into Employees values ('Sara', '03/17/1970')
Insert into Employees values ('David', '04/05/1978')
Go

The following example returns the last day of the month from the DateOfBirth of every employee.
SELECT Name, DateOfBirth, EOMONTH(DateOfBirth) AS LastDay
FROM Employees

If you want just the last day instead of the full date, you can use DATEPART function
SELECT Name, DateOfBirth, DATEPART(DD,EOMONTH(DateOfBirth)) AS LastDay
FROM Employees

******************* DATEFROMPARTS function ******************************
DATEFROMPARTS function
Introduced in SQL Server 2012
Returns a date value for the specified year, month, and day
The data type of all the 3 parameters (year, month, and day) is integer
If invalid argument values are specified, the function returns an error
If any of the arguments are NULL, the function returns null

Syntax : DATEFROMPARTS ( year, month, day )

Example : All the function arguments have valid values, so DATEFROMPARTS returns the expected date

SELECT DATEFROMPARTS ( 2015, 10, 25) AS [Date]

Example : Invalid value specified for month parameter, so the function returns an error

SELECT DATEFROMPARTS ( 2015, 15, 25) AS [Date]

Output : Cannot construct data type date, some of the arguments have values which are not valid.

Example : NULL specified for month parameter, so the function returns NULL.

SELECT DATEFROMPARTS ( 2015, NULL, 25) AS [Date]

Other new date and time functions introduced in SQL Server 2012
EOMONTH (Discussed in Part 125 of SQL Server tutorial)
DATETIMEFROMPARTS : Returns DateTime
 Syntax : DATETIMEFROMPARTS ( year, month, day, hour, minute, seconds, milliseconds )
SMALLDATETIMEFROMPARTS : Returns SmallDateTime
 Syntax : SMALLDATETIMEFROMPARTS ( year, month, day, hour, minute )
TIMEFROMPARTS
DATETIME2FROMPARTS 
DATETIMEOFFSETFROMPARTS

************** OFFSET vs FETCH NEXT function ***********************

Let's understand this with an example. We will use the following tblProducts table for the examples in this video. 

SQL Script to create tblProducts table
Create table tblProducts
(
 Id int primary key identity,
 Name nvarchar(25),
 [Description] nvarchar(50),
 Price int
)
Go

SQL Script to populate tblProducts table with 100 rows
Declare @Start int
Set @Start = 1

Declare @Name varchar(25)
Declare @Description varchar(50)

While(@Start [= 100)
Begin
 Set @Name = 'Product - ' + LTRIM(@Start)
 Set @Description = 'Product Description - ' + LTRIM(@Start)
 Insert into tblProducts values (@Name, @Description, @Start * 10)
 Set @Start = @Start + 1
End

OFFSET FETCH Clause
Introduced in SQL Server 2012
Returns a page of results from the result set
ORDER BY clause is required

OFFSET FETCH Syntax : 

SELECT * FROM Table_Name
ORDER BY Column_List
OFFSET Rows_To_Skip ROWS
FETCH NEXT Rows_To_Fetch ROWS ONLY

The following SQL query
1. Sorts the table data by Id column
2. Skips the first 10 rows and
3. Fetches the next 10 rows

SELECT * FROM tblProducts
ORDER BY Id
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY

From the front-end application, we would typically send the PAGE NUMBER and the PAGE SIZE to get a page of rows. The following stored procedure accepts PAGE NUMBER and the PAGE SIZE as parameters and returns the correct set of rows.

CREATE PROCEDURE spGetRowsByPageNumberAndSize
@PageNumber INT,
@PageSize INT
AS
BEGIN
 SELECT * FROM tblProducts
 ORDER BY Id
 OFFSET (@PageNumber - 1) * @PageSize ROWS
 FETCH NEXT @PageSize ROWS ONLY
END

With PageNumber = 3 and PageSize = 10, the stored procedure returns the correct set of rows
EXECUTE spGetRowsByPageNumberAndSize 3, 10

************** Diff bw Sequence and identity function *******************
create table users (id int primary key, name nvarcar(50), gender nvarchar(10) )

create sequence [dbo].[SequenceObject]
AS INT
START WITH 1
INCREMENT BY 1

create sequence [dbo].[SequenceObject]
AS INT
START WITH 1
MAXVALUE 5

create sequence [dbo].[SequenceObject]
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 5
CYCLE

DROP SEQUENCE [dbo].[SequenceObject]

select NEXT VALUE FOR [dbo].[SequenceObject]

create table customers (id int primary key, name nvarchar(50), gender nvarchar(10))

insert into customers values(NEXT VALUE FOR [dbo].[SequenceObject],'Ben','Male') 
insert into customers values(NEXT VALUE FOR [dbo].[SequenceObject],Sara'','Female')
insert into customers values(NEXT VALUE FOR [dbo].[SequenceObject],'Tom','Male')


Identity:
---------

Identity property is a table column property meaning it is tied to the table.

To generate the next identity value, a row has to be inserted into the table.

Maximum value for the identity property cannot be specified. The maximum value will be the maximum value of the corresponding column data type.

Identity property does not have any option to automatically restart the identity values.

Sequence:
---------
Sequence is a user-defined database object and is not tied to any specific table meaning it's value can be shared by multiple tables

With sequence object there is no need to insert a row into the table to generate the next sequence value. 

With the sequence object you can use the MAXVALUE option to specify the maximum value. If the MAXVALUE option is not specified for the sequence object, then the maximum value will be the maximum value of it's data type.

With the Sequence object CYCLE option can be used to specify whether the sequence should restart automatically when the max value (for incrementing sequence object) or min value(for decrementing sequence object) is reached.



*************** DateTime vs DateTime2 function ***************



*************** DateTime vs DateTime2 function ***************

In SQL Server we have different categories of window functions
Aggregate functions - AVG, SUM, COUNT, MIN, MAX etc..
Ranking functions - RANK, DENSE_RANK, ROW_NUMBER etc..
Analytic functions - LEAD, LAG, FIRST_VALUE, LAST_VALUE etc...

OVER Clause defines the partitioning and ordering of a rows (i.e a window) for the above functions to operate on. Hence these functions are called window functions. The OVER clause accepts the following three arguments to define a window for these functions to operate on.
ORDER BY : Defines the logical order of the rows
PARTITION BY : Divides the query result set into partitions. The window function is applied to each partition separately.
ROWSor RANGE clause : Further limits the rows within the partition by specifying start and end points within the partition.

The default for ROWS or RANGE clause is
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

Let us understand the use of ROWS or RANGE clause with an example. 

Compute average salary and display it against every employee

We might think the following query would do the job. 
SELECT Name, Gender, Salary, 
    AVG(Salary) OVER(ORDER BY Salary) AS Average
FROM Employees

As you can see from the result, the above query does not produce the overall salary average. It produces the average of the current row and the rows preceeding the current row. This is because, the default value of ROWS or RANGE clause (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) is applied.

To fix this, provide an explicit value for ROWS or RANGE clause as shown below. ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING tells the window function to operate on the set of rows starting from the first row in the partition to the last row in the partition.

SELECT Name, Gender, Salary, 
    AVG(Salary) OVER(ORDER BY Salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Average
FROM Employees

The same result can also be achieved by using RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

Well, what is the difference between ROWS and RANGE
We will discuss this in a later video

The following query can be used if you want to compute the average salary of 
1. The current row
2. One row PRECEDING the current row and 
3. One row FOLLOWING the current row

SELECT Name, Gender, Salary, 
    AVG(Salary) OVER(ORDER BY Salary ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS Average
FROM Employees










